#
# For processing hdf files generated by fenics 
# 
from dolfin import *
import numpy as np
import matplotlib.pylab as plt
from scipy.interpolate import griddata

def InterpolateData(mesh,u,dims=2,mode="line",doplot=False, res=100):    
    if dims==3: 
      raise RuntimeError("Only 2D support right now") 

#    mesh = results.mesh
    #dims = np.max(mesh.coordinates(),axis=0) - np.min(mesh.coordinates(),axis=0)
    mmin = np.min(mesh.coordinates(),axis=0)
    mmax = np.max(mesh.coordinates(),axis=0)
    
    #u = results.u_n.split()[0]
    #u = results.u_n
    up = project(u,FunctionSpace(mesh,"CG",1))
    #(gx,gy,gz) = np.mgrid[0:dims[0]:(res*1j),
    #                      dims[1]/2.:dims[1]/2.:1j,
    #                      0:dims[2]:(res*1j)]
    #if dims==3:

    
    if mode=="slice":
      #(gx,gy,gz) = np.mgrid[mmin[0]:mmax[0]:(res*1j),
      #                      mmin[1]:mmax[1]:(res*1j),  
      #                            0:0:1j]
      #img0 = griddata(mesh.coordinates(),up.vector(),(gx,gy,gz))
      (gx,gy) = np.mgrid[mmin[0]:mmax[0]:(res*1j),
                            mmin[1]:mmax[1]:(res*1j)]  
      img0 = griddata(mesh.coordinates(),up.vector(),(gx,gy))

      #print np.shape(img0)
      img0 = np.reshape(img0[:,:,0],[res,res])

      if doplot:
        plt.pcolormesh(img0)
        plt.colorbar()
        plt.gcf().savefig("test.png")
      return img0

    if mode=="line":
    
      yMid = 0.5*(mmax[1]+mmin[1])
      #(gx,gy,gz) = np.mgrid[mmin[0]:mmax[0]:(res*1j),
      #                      yMid:yMid:1j,  
      #                      0:0:1j]
      #line = griddata(mesh.coordinates(),up.vector(),(gx,gy,gz))

      #(gx,gy) = np.mgrid[mmin[0]:mmax[0]:(res*1j),
      #                      yMid:yMid:1j]  
      tol = 0.1
      yMid = 0.1   
      print mmin,mmax
      (gx,gy) = np.mgrid[mmin[0]:mmax[0]:(res*1j),
                            (yMid):(yMid+tol):100j]  
      line = griddata(mesh.coordinates(),up.vector(),(gx,gy))
      
      print np.shape(line)
      line = np.mean(line,axis=0)
      print np.shape(line)
      #img0 = np.reshape(line[:,0,0],[res])
      line = np.ndarray.flatten(line)
      #print np.shape(line)
      if doplot:
        plt.plot(line)
        plt.gcf().savefig("test1.png") 
      return line 


def ReadHdfSlice(hdfFile,i=0,verbose=True):
  hdf = HDF5File(mpi_comm_world(),hdfFile,'r')
  mesh = Mesh()
  hdf.read(mesh,"mesh",False)
  V = FunctionSpace(mesh,"CG",1)
  u = Function(V)

  dataset = "uCa/vector_%d"%i
  attr = hdf.attributes(dataset)
  if verbose:
      print 'Retrieving time step:', attr['timestamp']
  hdf.read(u, dataset)
  return mesh,u 

def ReadHdf(hdfFile,ssl=False,verbose=False):
  hdf = HDF5File(mpi_comm_world(),hdfFile,'r')
  mesh = Mesh()
  hdf.read(mesh,"mesh",False)
  #hdf.read(z,"nEntries") 
  V = FunctionSpace(mesh,"CG",1)
  u = Function(V)
  R = FunctionSpace(mesh,"R",0)
  ur = Function(R)

  # temp hack for grabbing doubles
  x = Function(V) 
  hdf.read(x,"volSSL")
  volSSL = x.vector()[0]
  hdf.read(x,"volCleft")
  volCleft= x.vector()[0]
  hdf.read(x,"volCyto")  
  volCyto= x.vector()[0]
  print volCleft,volSSL,volCyto
  
  attr = hdf.attributes("uCa")
  nsteps = attr['count']

  # arrays
  concsCa = np.zeros(nsteps) 
  concsCaSSL = np.zeros(nsteps) 
  concsCaCleft = np.zeros(nsteps) 

  
  ts = np.arange(nsteps)
  for i in range(nsteps):
    # uCa Field
    dataset = "uCa/vector_%d"%i
    attr = hdf.attributes(dataset)
    if verbose:
      print 'Retrieving time step:', attr['timestamp']
    hdf.read(u, dataset)
    #print "Assemble %d/%f" % (i,assemble(u*dx))
    concsCa[i] = assemble(u*dx) # /volCyto

    # uCaSSL scalar
    if ssl:
      dataset = "uCaSSL/vector_%d"%i
      attr = hdf.attributes(dataset)
      hdf.read(ur, dataset)
      #print "Assemble %d/%f" % (i,assemble(ur*dx))
      concsCaSSL[i]= assemble(ur*dx) # /volSSL

    # uCaCleft scalar
    dataset = "uCaCleft/vector_%d"%i
    attr = hdf.attributes(dataset)
    hdf.read(ur, dataset)
    #print "Assemble %d/%f" % (i,assemble(ur*dx))
    concsCaCleft[i]= assemble(ur*dx) # /volCleft

    # 
    if verbose:
      print concsCaCleft[i], concsCaSSL[i], concsCa[i]

  hdf.close()
  return ts,concsCaCleft, concsCaSSL, concsCa


#!/usr/bin/env python
import sys
##################################
#
# Revisions
#       10.08.10 inception
#
##################################

#
# ROUTINE  
#


#
# Message printed when program run without arguments 
#
def helpmsg():
  scriptName= sys.argv[0]
  msg="""
Purpose: 
 
Usage:
"""
  msg+="  %s -read <hdfname>" % (scriptName)
  msg+="""
  
 
Notes:

"""
  return msg

#
# MAIN routine executed when launching this script from command line 
#
if __name__ == "__main__":
  import sys
  msg = helpmsg()
  remap = "none"

  if len(sys.argv) < 2:
      raise RuntimeError(msg)

  #fileIn= sys.argv[1]
  #if(len(sys.argv)==3):
  #  1
  #  #print "arg"

  # Loops over each argument in the command line 
  ssl = False
  for i,arg in enumerate(sys.argv):
    # calls 'doit' with the next argument following the argument '-validation'
    if(arg=="-ssl"):
      ssl = True
    if(arg=="-read"):
      arg1=sys.argv[i+1] 
      ReadHdf(arg1,ssl=ssl,verbose=True)
      quit()
  





  raise RuntimeError("Arguments not understood")




"""
For processing ODE outputs in support of Satin/Despa collaborations 
"""
import cPickle as pickle
import runner 
import matplotlib.pylab as plt
import numpy as np 
from runShannonTest import *
runner.init()

mM_to_uM=1e3

def readOut(name = "PCa0.75kss0.25.pickle"):
  print "Reading " + name  
  pkl_file = open(name, 'rb')
  data1 = pickle.load(pkl_file)  
  pkl_file.close()
     
  return data1  
    

def analyOut(data1,state="Cai",label=""):
  si = data1['s']
  pi = data1['p']

  np.shape(si)
  temp = si[:,runner.model.state_indices(state)]
  # take last third
  idx = np.int(np.shape(temp)[0]*2/3)
  #print idx
  ts = data1['t']
  ts = ts[idx:]
  temp = temp[(1+idx):]
  plt.plot(ts,temp*mM_to_uM,label=label)
    
  PCa = pi[runner.model.parameter_indices("PCa")]
  ks = pi[runner.model.parameter_indices("ks")]
  minCai = np.min(temp)
  maxCai = np.max(temp)  
    
  return (PCa,ks,minCai,maxCai)
    
#name =  "/tmp/PCa1.00ks1.00.pickle"      
#d = readOut(name)
#pca,ks,minCai,maxCai = analyOut(d)

def ProcessOneDOutputs(var1Name,names,allVars,state="Cai",xlim=None,ylim=None):
  print "WARNING: does not include time steps" 
  for i,name in enumerate(names):               
      print name
      d = readOut(name+".pickle")
      print np.shape(d['s'])
      s = d['s']
      caSR = s[:,runner.model.state_indices(state)]         
      plt.plot(caSR*mM_to_uM,label="%s=%4.2f"%(var1Name,allVars[i]))  

  plt.legend(loc=2)

  if xlim!=None:
    plt.xlim(xlim)
  if ylim!=None:
    plt.ylim(ylim)
  plt.ylabel("[%s] [uM]" % state)  
  plt.xlabel("timesteps []") # t [ms]") 
  name = state+"transients%s"%(var1Name)
  plt.gcf().savefig(name+".png")

def ProcessTwoDOutputs(allKeys,allVars,state="Cai",ylims=None):
  vars1 = allVars[0]
  var1Name = allKeys[0]
  vars2 = allVars[1]
  var2Name = allKeys[1]

  outsMin = np.zeros([np.shape(vars1)[0],np.shape(vars2)[0]])
  outsMax = np.zeros(outsMin.shape)


  # assuming there exist two iterated var 
  #for i, PCa in enumerate(PCas):
  for i, var1Val in enumerate(vars1):
    plt.figure()  
    plt.title("%s=%3.2f"%(var1Name,var1Val))
    #for j, ks in enumerate(kss):
    for j, var2Val in enumerate(vars2):
        name =namer(var1Name,var1Val,var2Name,var2Val)+".pickle"
        #print name
        d = readOut(name) 
        #print np.shape(d['s'])
        dummy,dummy,minCai,maxCai = analyOut(d,state=state,label="%s=%3.2f"%(var2Name,var2Val))
        outsMin[i,j]= minCai 
        outsMax[i,j]= maxCai 
    if ylims!=None:    
      plt.ylim(ylims)  
    plt.ylabel(state+" [uM]")
    plt.xlabel("t [ms]")  
    plt.legend(loc=0,ncol=3)  
    name = state+"transients%s%3.2f"%(var1Name,var1Val)
    plt.gcf().savefig(name.replace(".","p")+".png")
    
  return outsMin,outsMax
    
# labeli - label corresponding to key[i]
def TwoDPlots(allKeys,allVars,outsMin, outsMax,label0="",label1="",state="Cai"):
    xv, yv = np.meshgrid(allVars[1],allVars[0])

    plt.figure()
    plt.subplot(2,2,1)
    plt.title(state+" min")
    plt.pcolormesh(xv,yv,outsMin*mM_to_uM)#,shading='gouraud')
    plt.xlim([np.min(allVars[1]),np.max(allVars[1])])
    plt.ylim([np.min(allVars[0]),np.max(allVars[0])])
    plt.ylabel(label0)
    plt.colorbar()

    plt.subplot(2,2,2)
    plt.title(state+" max")
    plt.pcolormesh(xv,yv,outsMax*mM_to_uM)
    plt.xlim([np.min(allVars[1]),np.max(allVars[1])])
    plt.ylim([np.min(allVars[0]),np.max(allVars[0])])
    plt.ylabel(label0)
    plt.colorbar()
    plt.xlabel(label1)        
    
    
    plt.subplot(2,2,3)
    plt.title(state+" diff")
    plt.pcolormesh(xv,yv,(outsMax-outsMin)*mM_to_uM)
    plt.ylabel(label0)
    plt.xlim([np.min(allVars[1]),np.max(allVars[1])])
    plt.ylim([np.min(allVars[0]),np.max(allVars[0])])
    plt.colorbar()
    plt.xlabel(label1)         
    plt.tight_layout()
    
    name = state+"_extrema.png"
    plt.gcf().savefig(name)        

